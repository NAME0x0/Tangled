# Rulesets

1. **Verify Information**: Always verify information before presenting it. Do not assume or speculate without clear evidence.
2. **File-by-File Changes**: Make changes file by file and allow review opportunities.
3. **No Apologies**: Never include apologies in communications or code comments.
4. **No Understanding Feedback**: Avoid discussing your level of understanding in documentation or comments.
5. **No Whitespace Suggestions**: Do not suggest changes solely to whitespace.
6. **No Summaries**: Do not provide summaries of the changes made.
7. **No Inventions**: Do not invent changes beyond what is explicitly requested.
8. **No Unnecessary Confirmations**: Avoid asking for confirmations on information already provided.
9. **Preserve Existing Code**: Do not remove unrelated code or functionalities; maintain existing structures.
10. **Single Chunk Edits**: Provide all edits in one consolidated update instead of multiple step-by-step instructions.
11. **No Implementation Checks**: Do not ask the user to verify visible implementations.
12. **No Unnecessary Updates**: Avoid suggesting changes when there are no modifications needed.
13. **Provide Real File Links**: Always supply links to the actual files instead of generated context files.
14. **No Memory of Previous x.md Files**: Do not reference previous x.md files; note if content is identical.
15. **No Current Implementation Discussion**: Do not display or discuss current implementations unless explicitly requested.
16. **Check Context File Content**: Always review current file contents before making changes.
17. **Use Explicit Variable Names**: Prefer descriptive, explicit variable names over ambiguous ones.
18. **Follow Consistent Coding Style**: Adhere to the project’s established coding style consistently.
19. **Prioritize Performance**: Consider and prioritize performance improvements where applicable.
20. **Security-First Approach**: Always implement necessary security measures.
21. **Test Coverage**: Include or suggest appropriate unit tests for any new or modified code.
22. **Error Handling**: Implement robust error handling and logging.
23. **Modular Design**: Encourage modular design to enhance maintainability and reusability.
24. **Version Compatibility**: Ensure changes are compatible with the project's language or framework versions.
25. **Avoid Magic Numbers**: Replace hardcoded values with named constants for clarity.
26. **Consider Edge Cases**: Always consider and manage potential edge cases.
27. **Use Assertions**: Incorporate assertions to validate assumptions and catch errors early.
28. **Embrace Creative Iteration**: Allow the IDE to experiment with innovative implementations and generate multiple viable solutions when specs are open-ended.
29. **Spec-Driven Adaptation**: Leverage detailed spec files to generate code that meets explicit requirements while anticipating future enhancements.
30. **Proactive Improvement Suggestions**: When specifications are ambiguous, propose improvements and alternative approaches based on best practices.
31. **Flexible Precision**: Balance strict adherence to requirements with creative freedom to deliver senior-level code.
32. **Iterative Refinement Mode**: Integrate a process that generates initial code and refines it in one consolidated update based on feedback.
33. **Adaptive Code Architecture**: Dynamically adjust code structure to incorporate new insights and support future changes seamlessly.
34. **Contextual Creativity**: Generate creative code that remains coherent within the project’s context when specifications allow flexibility.
35. **User Insight Integration**: Anticipate latent user needs and align code generation with the evolving project vision.
36. **Balanced Minimalism and Clarity**: Ensure code is both concise and detailed, capturing creative decisions without excess verbosity.
37. **Self-Audit and Testing**: Incorporate self-review mechanisms and unit tests to validate creative enhancements.
38. **Seamless Environment Integration**: Guarantee that creative changes integrate smoothly with the existing development environment and toolchain.
39. **Prioritize the User’s Vision**: Align code generation with the evolving vision, allowing the IDE to pivot as project needs change.
40. **No Over-Correction**: Avoid overriding the user’s creative direction; leave space for exploration and later refinement.
41. **Encourage Experimentation**: Enable the IDE to explore alternative code patterns and approaches to foster innovation.
42. **Rapid Prototyping with Feedback Loops**: Implement immediate feedback loops for continuous refinement without disrupting workflow.
43. **Context Preservation in Iteration**: Retain context from previous iterations to ensure consistency with the overall project vision.
44. **Innovative Exception Handling**: Apply creative yet robust error handling that resolves issues and informs future improvements.
45. **Maintain a Log of Creative Iterations**: Track creative iterations and user preferences over time to guide future suggestions.
46. **Prioritize User’s Intuition**: Trust subtle creative cues from the user so that the final output resonates with the intended vibe.
47. **Adaptive Learning from Feedback**: Continuously learn from iterative feedback to enhance the quality of creative code suggestions.
48. **Balance Structure with Fluidity**: Ensure code remains structurally robust while allowing fluid, creative modifications.
49. **Integrated Visual Feedback**: Provide visual cues within the IDE to quickly assess the creative impact of changes.
50. **Encourage Code Aesthetics**: Promote elegant, readable, and aesthetically pleasing code that reflects both functionality and creativity.
51. **Documentation for Creative Choices**: Briefly document creative deviations and the rationale behind them to support future modifications.
52. **Ensure Reproducibility of Creative Iterations**: Guarantee that creative code remains reproducible and consistent, even in an experimental environment.
53. **Celebrate Milestones**: Highlight and celebrate successful creative iterations to reinforce the value of vibe coding.
54. **Dynamic Prompt Management**: Continuously refine AI prompts to extract more precise and creative code generation.
55. **User-Defined Vibe Settings**: Allow users to set personal “vibe” parameters (e.g., creativity level, precision, aggressiveness) for tailored output.
56. **Versioning of Creative Iterations**: Maintain a comprehensive version history of creative iterations for traceability and rollback.
57. **Automated Merge Conflict Resolution**: Integrate mechanisms to automatically resolve merge conflicts during creative coding sessions.
58. **Continuous Context Awareness**: Ensure the IDE preserves complete context across sessions to maintain consistency in creative output.
59. **Real-Time Collaboration Support**: Enable simultaneous coding by multiple users to support live collaboration and shared creative input.
60. **Automated Code Refactoring**: Periodically review and refactor code to sustain clarity and performance without stifling creativity.
61. **Interactive Debugging Mode**: Provide an interactive mode that visualizes errors and facilitates creative troubleshooting on the fly.
62. **User Feedback Loop Integration**: Seamlessly incorporate real-time user feedback to instantly adjust code generation.
63. **Enhanced Modular Testing**: Automatically generate modular tests for each creative module to ensure independent reliability.
64. **Seamless Integration with External APIs**: Ensure creative code can easily interface with external libraries and services for expanded functionality.
65. **Contextual Documentation Generation**: Auto-generate documentation capturing creative decisions and rationale for future reference.
66. **Flexible Error Reporting**: Customize error reporting to balance technical details with creative brevity for rapid iteration.
67. **Adaptive Security Protocols**: Dynamically adjust security measures during creative iterations to safeguard experimental code.
68. **Intuitive Rollback Functionality**: Enable one-click rollback to previous creative states if new iterations introduce issues.
69. **Unified Code Aesthetics Enforcement**: Apply consistent code aesthetics that honor both creative flair and industry best practices.
70. **Scalable Architecture Planning**: Ensure creative coding efforts consider future scalability and maintainability from the start.
71. **Proactive Performance Monitoring**: Integrate performance metrics that proactively alert users to potential bottlenecks in creative iterations.
72. **Holistic Environment Calibration**: Regularly calibrate the entire development environment to align creative outputs with evolving project objectives.
73. **Store Datasets in SQL Databases**: Do not store datasets in JSON; use SQL databases for data persistence.
74. **No Example Data in Production**: Avoid including example data in production repositories; only include it during debugging.
75. **Clean Debugging Artifacts**: Ensure that any files or artifacts created solely for debugging are removed immediately after the debugging session.
76. **Centralized Debug Logging**: Use centralized logging systems rather than creating extra debugging files.
77. **Automated Debug File Cleanup**: Integrate automated scripts to delete temporary debugging files after tests.
78. **Dataset Versioning via Migrations**: Manage dataset versioning through SQL database schema migrations rather than JSON snapshots.
79. **Minimal Debug Footprint**: Limit the number of files created for debugging to reduce repository clutter.
80. **No Persistent Debug Files**: Ensure that debug files do not persist in the repository; delete them after use.
81. **Secure Storage of Sensitive Data**: Store sensitive dataset information securely in SQL databases with encryption.
82. **Data Integrity Checks**: Implement integrity checks on SQL datasets to ensure data consistency.
83. **Versioned Data Migration Scripts**: Provide clear, version-controlled data migration scripts for SQL databases.
84. **Prefer SQL for Large Datasets**: Use SQL databases over JSON for large or complex datasets to ensure scalability.
85. **Avoid Hardcoding Example Data**: Do not hardcode example data into code files except temporarily for debugging.
86. **Modular Debugging Scripts**: Create debugging scripts that are modular and easily removable post-debugging.
87. **Document Debug Procedures**: Clearly document debugging procedures and mark temporary files for deletion.
88. **Automate Debug Cleanup in CI/CD**: Automate the deletion of debug files via CI/CD pipelines to maintain repository cleanliness.
89. **Abstract Data Access Layers**: Use a dedicated data access layer to interface with SQL databases instead of handling JSON directly.
90. **Prevent SQL Injection**: Ensure all SQL queries are parameterized to prevent injection vulnerabilities.
91. **Optimize SQL Queries**: Regularly review and optimize SQL queries for performance.
92. **Utilize ORM Tools**: Prefer established ORM tools for interacting with SQL databases over manual JSON manipulation.
93. **Avoid Redundant Data Files**: Do not create redundant data files for debugging; rely on logging and monitoring tools.
94. **Isolate Debug Environments**: Perform debugging in temporary environments that do not affect the main repository.
95. **Conduct Regular Repository Audits**: Regularly audit the repository to ensure no debugging files or example data remain.
96. **Enforce Data Separation**: Clearly separate production data from debugging and testing datasets.
97. **Implement Data Backup Protocols**: Maintain robust backup protocols for SQL databases and avoid local JSON backups.
98. **Limit Data Exposure in Logs**: Ensure logs do not expose sensitive dataset information.
99. **Continuous Improvement in Data Management**: Regularly update data management practices to leverage advances in SQL and database security.
